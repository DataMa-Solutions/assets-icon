/**
 * Vue3 Icons Font Builder (Standalone)
 * 
 * This script generates a standalone icon font from the Vue3 icons folder.
 * It reads SVG files directly from icons/vue3/ and generates font files.
 * 
 * Features:
 * - Independent of other build scripts
 * - Processes only icons/vue3/ folder
 * - Optimized for stroke-based line art icons (not filled icons)
 * - Preserves rounded edges and line styles
 * 
 * Usage:
 *   node scripts/build-font.js
 * 
 * Output:
 *   - dist/fonts/vue3-icons.woff2
 *   - dist/fonts/vue3-icons.woff
 *   - dist/fonts/vue3-icons.ttf
 *   - dist/fonts/vue3-icons.css
 *   - dist/fonts/vue3-icons.html (demo file)
 *   - dist/fonts/vue3-icons-mapping.json
 */

const fs = require('fs');
const path = require('path');
const webfont = require('webfont').default;
const cheerio = require('cheerio');

/**
 * Configuration
 */
const CONFIG = {
  fontName: 'vue3-icons',
  fontFamily: 'Vue3 Icons',
  classNamePrefix: 'vue3-icon',
  defaultFontSize: '24px',
  fontBaseSize: 1000, // Base size for font generation (higher = better quality)
  startUnicode: 0xE000, // Private Use Area start (E000-EFFF)
  iconsDir: path.join(__dirname, '../icons/vue3'),
  outputDir: path.join(__dirname, '../dist/fonts')
};

/**
 * Load SVG files directly from icons/vue3/ folder
 */
function loadSvgFiles() {
  const iconsDir = CONFIG.iconsDir;
  
  if (!fs.existsSync(iconsDir)) {
    console.error(`âŒ Icons directory not found: ${iconsDir}`);
    process.exit(1);
  }
  
  const files = fs.readdirSync(iconsDir)
    .filter(file => file.endsWith('.svg'))
    .sort();
  
  if (files.length === 0) {
    console.error(`âŒ No SVG files found in: ${iconsDir}`);
    process.exit(1);
  }
  
  return files.map(file => ({
    name: file.replace('.svg', ''),
    path: path.join(iconsDir, file)
  }));
}

/**
 * Validate and prepare SVG for font generation
 * Vue3 icons MUST use filled paths for proper webfont rendering
 */
function validateAndPrepareSvg(svgContent, iconName) {
  const $ = cheerio.load(svgContent, { xmlMode: true });
  const $svg = $('svg');
  
  // Check for required viewBox
  const viewBox = $svg.attr('viewBox');
  if (!viewBox) {
    console.warn(`âš ï¸  Icon "${iconName}" missing viewBox attribute, using default "0 0 24 24"`);
    $svg.attr('viewBox', '0 0 24 24');
  }
  
  // Validate standard format: viewBox should be "0 0 24 24"
  if (viewBox && viewBox !== '0 0 24 24') {
    console.warn(`âš ï¸  Icon "${iconName}" has non-standard viewBox: ${viewBox}`);
  }
  
  // Check for paths and validate they use fill, not stroke
  const $paths = $svg.find('path');
  $paths.each((i, element) => {
    const $path = $(element);
    const stroke = $path.attr('stroke');
    const fill = $path.attr('fill');
    
    // ERROR: If icon uses stroke, it won't work properly with webfont
    if (stroke) {
      console.error(`âŒ Icon "${iconName}" uses stroke attribute!`);
      console.error(`   Webfont does NOT support stroke-based SVGs.`);
      console.error(`   Please convert to filled paths using "Outline Stroke" in your design tool.`);
      console.error(`   See .cursor/rules/vue3-icons-style.mdc for instructions.`);
      // Remove stroke attributes but warn user
      $path.removeAttr('stroke');
      $path.removeAttr('stroke-width');
      $path.removeAttr('stroke-linecap');
      $path.removeAttr('stroke-linejoin');
    }
    
    // Ensure fill="currentColor" for proper rendering
    if (!fill || fill === 'none') {
      $path.attr('fill', 'currentColor');
    }
  });
  
  // Remove problematic attributes
  $svg.removeAttr('id');
  $svg.find('[data-name]').removeAttr('data-name');
  
  return $.html();
}

/**
 * Prepare SVG file for webfont generation
 */
function prepareSvgForFont(iconFile, tempDir) {
  const iconName = iconFile.name;
  const svgPath = iconFile.path;
  
  // Read original SVG
  const svgContent = fs.readFileSync(svgPath, 'utf8');
  
  // Validate and prepare SVG for font generation
  const processedSvg = validateAndPrepareSvg(svgContent, iconName);
  
  // Write to temporary directory
  const outputPath = path.join(tempDir, `${iconName}.svg`);
  fs.writeFileSync(outputPath, processedSvg);
  
  return outputPath;
}

/**
 * Generate CSS file for the font
 */
function generateCSS(fontName, fontFamily, classNamePrefix, iconMap) {
  const timestamp = new Date().toISOString();
  
  const css = `/**
 * ${fontFamily} - Icon Font
 * Generated: ${timestamp}
 * 
 * This file is automatically generated from icons/vue3/ folder.
 * Do not edit manually - regenerate using: node scripts/build-font.js
 */

/* Font Face Definition */
@font-face {
  font-family: '${fontFamily}';
  src: url('${fontName}.woff2') format('woff2'),
       url('${fontName}.woff') format('woff'),
       url('${fontName}.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: block;
}

/* Base Icon Class */
.${classNamePrefix} {
  /* Font properties */
  font-family: '${fontFamily}', sans-serif;
  font-weight: normal;
  font-style: normal;
  font-size: ${CONFIG.defaultFontSize};
  
  /* Display properties */
  display: inline-block;
  line-height: 1;
  vertical-align: middle;
  
  /* Text properties */
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;
  
  /* Font smoothing */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  
  /* User interaction */
  user-select: none;
}

/* Individual Icon Classes */
${Object.entries(iconMap)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([iconName, unicode]) => {
    const className = iconName.replace(/-/g, '-');
    const unicodeHex = typeof unicode === 'number' 
      ? unicode.toString(16).toUpperCase().padStart(4, '0')
      : unicode.toString().padStart(4, '0');
    return `.${classNamePrefix}-${className}::before { content: '\\${unicodeHex}'; }`;
  })
  .join('\n')}

/* Size Modifiers */
.${classNamePrefix}-xs  { font-size: 0.75em; }  /* 18px at 24px base */
.${classNamePrefix}-sm  { font-size: 0.875em; } /* 21px at 24px base */
.${classNamePrefix}-lg  { font-size: 1.333em; } /* 32px at 24px base */
.${classNamePrefix}-xl  { font-size: 1.5em; }   /* 36px at 24px base */
.${classNamePrefix}-2x  { font-size: 2em; }     /* 48px at 24px base */
.${classNamePrefix}-3x  { font-size: 3em; }     /* 72px at 24px base */
.${classNamePrefix}-4x  { font-size: 4em; }     /* 96px at 24px base */
.${classNamePrefix}-5x  { font-size: 5em; }     /* 120px at 24px base */

/* Fixed Width (useful for lists/navigation) */
.${classNamePrefix}-fw {
  text-align: center;
  width: 1.25em;
}

/* Rotation Utilities */
.${classNamePrefix}-rotate-90  { transform: rotate(90deg); }
.${classNamePrefix}-rotate-180 { transform: rotate(180deg); }
.${classNamePrefix}-rotate-270 { transform: rotate(270deg); }

/* Flip Utilities */
.${classNamePrefix}-flip-h { transform: scaleX(-1); }
.${classNamePrefix}-flip-v { transform: scaleY(-1); }
`;

  return css;
}

/**
 * Generate HTML demo file
 */
function generateHTMLDemo(fontName, fontFamily, classNamePrefix, iconMap) {
  const icons = Object.keys(iconMap).sort();
  const timestamp = new Date().toISOString();
  
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${fontFamily} - Icon Font Demo</title>
  <link rel="stylesheet" href="${fontName}.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      padding: 3rem;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    
    header {
      text-align: center;
      margin-bottom: 3rem;
      padding-bottom: 2rem;
      border-bottom: 2px solid #f0f0f0;
    }
    
    h1 {
      color: #333;
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      font-weight: 700;
    }
    
    .subtitle {
      color: #666;
      font-size: 1.125rem;
    }
    
    .badge {
      display: inline-block;
      background: #667eea;
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-left: 0.5rem;
    }
    
    .info-box {
      background: #f8f9fa;
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      border-left: 4px solid #667eea;
    }
    
    .info-box h3 {
      color: #333;
      margin-bottom: 1rem;
      font-size: 1.125rem;
    }
    
    .code-example {
      background: #2d3748;
      color: #e2e8f0;
      padding: 1.5rem;
      border-radius: 8px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      overflow-x: auto;
    }
    
    .code-example code {
      display: block;
      margin: 0.5rem 0;
      color: #68d391;
    }
    
    .code-example .comment {
      color: #a0aec0;
    }
    
    .section-title {
      font-size: 1.5rem;
      color: #333;
      margin: 2rem 0 1.5rem 0;
      font-weight: 600;
    }
    
    .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
    }
    
    .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      transition: all 0.2s;
      cursor: pointer;
      background: white;
    }
    
    .icon-item:hover {
      background: #f7fafc;
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
    }
    
    .icon-item i {
      font-size: 2.5em;
      color: #667eea;
      margin-bottom: 0.75rem;
    }
    
    .icon-name {
      font-size: 0.75rem;
      color: #4a5568;
      text-align: center;
      word-break: break-word;
      font-weight: 500;
    }
    
    .icon-unicode {
      font-size: 0.625rem;
      color: #a0aec0;
      margin-top: 0.25rem;
      font-family: monospace;
    }
    
    footer {
      text-align: center;
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 2px solid #f0f0f0;
      color: #718096;
      font-size: 0.875rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>${fontFamily}</h1>
      <p class="subtitle">
        Modern Line Art Icon Font
        <span class="badge">${icons.length} Icons</span>
      </p>
    </header>
    
    <div class="info-box">
      <h3>ğŸ“¦ Installation & Usage</h3>
      <div class="code-example">
        <code><span class="comment">&lt;!-- Include CSS --&gt;</span></code>
        <code>&lt;link rel="stylesheet" href="${fontName}.css"&gt;</code>
        <code></code>
        <code><span class="comment">&lt;!-- Use icons --&gt;</span></code>
        <code>&lt;i class="${classNamePrefix} ${classNamePrefix}-${icons[0]}"&gt;&lt;/i&gt;</code>
        <code>&lt;i class="${classNamePrefix} ${classNamePrefix}-${icons[0]} ${classNamePrefix}-2x"&gt;&lt;/i&gt;</code>
        <code>&lt;i class="${classNamePrefix} ${classNamePrefix}-${icons[0]} ${classNamePrefix}-lg ${classNamePrefix}-rotate-90"&gt;&lt;/i&gt;</code>
      </div>
    </div>
    
    <h2 class="section-title">ğŸ¨ Available Icons</h2>
    <div class="icon-grid">
      ${icons.map(iconName => {
        const className = iconName.replace(/-/g, '-');
        const unicode = iconMap[iconName];
        const unicodeHex = typeof unicode === 'number' 
          ? 'U+' + unicode.toString(16).toUpperCase().padStart(4, '0')
          : 'U+' + unicode.toString().padStart(4, '0');
        return `
      <div class="icon-item" onclick="copyClassName('${classNamePrefix}-${className}')" title="Click to copy class name">
        <i class="${classNamePrefix} ${classNamePrefix}-${className}"></i>
        <span class="icon-name">${iconName}</span>
        <span class="icon-unicode">${unicodeHex}</span>
      </div>`;
      }).join('')}
    </div>
    
    <footer>
      <p>Generated: ${timestamp}</p>
      <p>Font Family: ${fontFamily} â€¢ Base Size: ${CONFIG.defaultFontSize}</p>
    </footer>
  </div>
  
  <script>
    function copyClassName(className) {
      const text = '${classNamePrefix} ' + className;
      navigator.clipboard.writeText(text).then(() => {
        const notification = document.createElement('div');
        notification.textContent = 'Copied: ' + text;
        notification.style.cssText = 'position:fixed;top:20px;right:20px;background:#667eea;color:white;padding:1rem 1.5rem;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:1000;font-family:sans-serif;font-size:0.875rem;';
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 2000);
      });
    }
  </script>
</body>
</html>`;

  return html;
}

/**
 * Create temporary directory and clean it
 */
function prepareTempDirectory() {
  const tempDir = path.join(__dirname, '../.temp-vue3-font-svgs');
  
  // Create if doesn't exist
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
  }
  
  // Clean existing files
  const existingFiles = fs.readdirSync(tempDir);
  existingFiles.forEach(file => {
    const filePath = path.join(tempDir, file);
    if (fs.statSync(filePath).isFile()) {
      fs.unlinkSync(filePath);
    }
  });
  
  return tempDir;
}

/**
 * Main build function
 */
async function buildFont() {
  console.log('ğŸš€ Starting Vue3 Icons font generation...\n');
  console.log(`ğŸ“‚ Source: ${CONFIG.iconsDir}`);
  console.log(`ğŸ“¦ Output: ${CONFIG.outputDir}\n`);
  
  try {
    // Step 1: Load SVG files
    console.log('ğŸ“ Step 1: Loading SVG files from icons/vue3/...');
    const iconFiles = loadSvgFiles();
    const iconNames = iconFiles.map(f => f.name);
    
    console.log(`âœ… Found ${iconFiles.length} icons: ${iconNames.join(', ')}\n`);
    
    // Step 2: Prepare temporary directory
    console.log('ğŸ“ Step 2: Preparing temporary directory...');
    const tempDir = prepareTempDirectory();
    console.log(`âœ… Temp directory ready: ${tempDir}\n`);
    
    // Step 3: Process SVG files
    console.log('ğŸ”§ Step 3: Processing SVG files...');
    const processedSvgs = [];
    iconFiles.forEach(iconFile => {
      const svgPath = prepareSvgForFont(iconFile, tempDir);
      processedSvgs.push(svgPath);
      console.log(`   âœ“ ${iconFile.name}`);
    });
    console.log(`âœ… Processed ${processedSvgs.length} SVG files\n`);
    
    // Step 4: Generate font with webfont
    console.log('ğŸ”¤ Step 4: Generating font files with webfont...');
    const result = await webfont({
      files: path.join(tempDir, '*.svg'),
      fontName: CONFIG.fontName,
      formats: ['woff2', 'woff', 'ttf'],
      startUnicode: CONFIG.startUnicode,
      fontHeight: CONFIG.fontBaseSize,
      normalize: true,
      centerHorizontally: true,
      fontStyle: 'normal',
      fontWeight: 'normal',
      fixedWidth: false,
      descent: 128, // Add descent for better vertical alignment
      ascent: CONFIG.fontBaseSize - 128 // Adjust ascent accordingly
    });
    
    console.log(`âœ… Font generated successfully\n`);
    
    // Step 5: Create output directory
    console.log('ğŸ“¦ Step 5: Creating output directory...');
    if (!fs.existsSync(CONFIG.outputDir)) {
      fs.mkdirSync(CONFIG.outputDir, { recursive: true });
    }
    console.log(`âœ… Output directory ready: ${CONFIG.outputDir}\n`);
    
    // Step 6: Save font files
    console.log('ğŸ’¾ Step 6: Saving font files...');
    if (result.woff2) {
      const woff2Path = path.join(CONFIG.outputDir, `${CONFIG.fontName}.woff2`);
      fs.writeFileSync(woff2Path, result.woff2);
      console.log(`   âœ“ ${CONFIG.fontName}.woff2 (${(result.woff2.length / 1024).toFixed(2)} KB)`);
    }
    if (result.woff) {
      const woffPath = path.join(CONFIG.outputDir, `${CONFIG.fontName}.woff`);
      fs.writeFileSync(woffPath, result.woff);
      console.log(`   âœ“ ${CONFIG.fontName}.woff (${(result.woff.length / 1024).toFixed(2)} KB)`);
    }
    if (result.ttf) {
      const ttfPath = path.join(CONFIG.outputDir, `${CONFIG.fontName}.ttf`);
      fs.writeFileSync(ttfPath, result.ttf);
      console.log(`   âœ“ ${CONFIG.fontName}.ttf (${(result.ttf.length / 1024).toFixed(2)} KB)`);
    }
    console.log(`âœ… All font files saved\n`);
    
    // Step 7: Generate icon mapping
    console.log('ğŸ—ºï¸  Step 7: Generating icon mapping...');
    const iconMap = {};
    let currentUnicode = CONFIG.startUnicode;
    
    iconNames.forEach(iconName => {
      iconMap[iconName] = currentUnicode;
      currentUnicode++;
      
      // Warn if running out of Private Use Area
      if (currentUnicode > 0xEFFF) {
        console.warn(`âš ï¸  Warning: Exceeding Unicode Private Use Area (E000-EFFF)`);
      }
    });
    
    console.log(`âœ… Generated mapping for ${Object.keys(iconMap).length} icons\n`);
    
    // Step 8: Generate CSS file
    console.log('ğŸ¨ Step 8: Generating CSS file...');
    const css = generateCSS(CONFIG.fontName, CONFIG.fontFamily, CONFIG.classNamePrefix, iconMap);
    const cssPath = path.join(CONFIG.outputDir, `${CONFIG.fontName}.css`);
    fs.writeFileSync(cssPath, css);
    console.log(`   âœ“ ${CONFIG.fontName}.css`);
    console.log(`âœ… CSS file generated\n`);
    
    // Step 9: Generate HTML demo
    console.log('ğŸ“„ Step 9: Generating HTML demo...');
    const html = generateHTMLDemo(CONFIG.fontName, CONFIG.fontFamily, CONFIG.classNamePrefix, iconMap);
    const htmlPath = path.join(CONFIG.outputDir, `${CONFIG.fontName}.html`);
    fs.writeFileSync(htmlPath, html);
    console.log(`   âœ“ ${CONFIG.fontName}.html`);
    console.log(`âœ… HTML demo generated\n`);
    
    // Step 10: Save icon mapping JSON
    console.log('ğŸ’¾ Step 10: Saving icon mapping...');
    const mappingPath = path.join(CONFIG.outputDir, `${CONFIG.fontName}-mapping.json`);
    const mappingData = {
      fontName: CONFIG.fontName,
      fontFamily: CONFIG.fontFamily,
      classPrefix: CONFIG.classNamePrefix,
      generated: new Date().toISOString(),
      icons: iconMap
    };
    fs.writeFileSync(mappingPath, JSON.stringify(mappingData, null, 2));
    console.log(`   âœ“ ${CONFIG.fontName}-mapping.json (${Object.keys(iconMap).length} icons)`);
    console.log(`âœ… Icon mapping saved\n`);
    
    // Step 11: Cleanup temporary directory
    console.log('ğŸ§¹ Step 11: Cleaning up...');
    try {
      const filesToClean = fs.readdirSync(tempDir);
      filesToClean.forEach(file => {
        const filePath = path.join(tempDir, file);
        if (fs.statSync(filePath).isFile()) {
          fs.unlinkSync(filePath);
        }
      });
      fs.rmdirSync(tempDir);
      console.log(`âœ… Temporary directory cleaned\n`);
    } catch (err) {
      console.warn(`âš ï¸  Could not clean up temp directory: ${err.message}\n`);
    }
    
    // Success summary
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('âœ¨ Font generation completed successfully! âœ¨');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
    console.log(`ğŸ“Š Statistics:`);
    console.log(`   â€¢ Icons processed: ${iconNames.length}`);
    console.log(`   â€¢ Font formats: WOFF2, WOFF, TTF`);
    console.log(`   â€¢ Base size: ${CONFIG.fontBaseSize}px`);
    console.log(`   â€¢ Unicode range: U+${CONFIG.startUnicode.toString(16).toUpperCase()} - U+${(CONFIG.startUnicode + iconNames.length - 1).toString(16).toUpperCase()}\n`);
    console.log(`ğŸ“ Output files:`);
    console.log(`   â€¢ ${CONFIG.outputDir}/${CONFIG.fontName}.woff2`);
    console.log(`   â€¢ ${CONFIG.outputDir}/${CONFIG.fontName}.woff`);
    console.log(`   â€¢ ${CONFIG.outputDir}/${CONFIG.fontName}.ttf`);
    console.log(`   â€¢ ${CONFIG.outputDir}/${CONFIG.fontName}.css`);
    console.log(`   â€¢ ${CONFIG.outputDir}/${CONFIG.fontName}.html (demo)`);
    console.log(`   â€¢ ${CONFIG.outputDir}/${CONFIG.fontName}-mapping.json\n`);
    console.log(`ğŸ’¡ Usage example:`);
    console.log(`   <i class="${CONFIG.classNamePrefix} ${CONFIG.classNamePrefix}-${iconNames[0]}"></i>\n`);
    console.log(`ğŸŒ Open ${CONFIG.fontName}.html in your browser to see all icons!`);
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
    
  } catch (error) {
    console.error('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.error('âŒ Font generation failed!');
    console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
    console.error(`Error: ${error.message}\n`);
    if (error.stack) {
      console.error('Stack trace:');
      console.error(error.stack);
    }
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  buildFont();
}

module.exports = { buildFont };
